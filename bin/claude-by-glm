#!/bin/bash
#
# claude-by-glm - Claude Code launcher for Z.ai GLM models
#
# This script sets up the environment for using Z.ai GLM models
# with Claude Code, then launches the claude command.
#
# Platform support:
# - macOS: Keychain (security command)
# - Linux: libsecret (secret-tool)
# - Windows: Environment variable (ZAI_API_KEY)
#
# Environment variables:
#   GLM_MODEL_REPO - Optional: Custom model repository URL
#   GLM_SKIP_PATH  - If set, skip PATH modification
#
# Usage:
#   ~/.claude-glm-mcp/bin/claude-by-glm [claude arguments...]
#

set -euo pipefail

# Set trusted PATH immediately to prevent command injection
# This must be done BEFORE any credential handling or external commands
# Note: Not readonly because setup_path() may add project bin directory
export PATH="/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:/opt/homebrew/bin"

# Script directory
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_DIR="$(dirname "$SCRIPT_DIR")"

# Source shared utilities
source "$PROJECT_DIR/scripts/common-utils.sh"

# Source credential abstraction (loads security.conf)
source "$PROJECT_DIR/credentials/common.sh"

# Initialize credential backend
credential_init

# Check if running in SSH session
is_ssh_session() {
    [[ -n "${SSH_CLIENT:-}" ]] || [[ -n "${SSH_TTY:-}" ]] || [[ -n "${SSH_CONNECTION:-}" ]]
}

# Check if keychain is accessible (macOS only)
check_keychain_accessible() {
    if [[ "$CREDENTIAL_PLATFORM" == "macos" ]]; then
        # Try to access keychain without verbose output
        # Use absolute path to prevent PATH poisoning
        /usr/bin/security find-generic-password -s "$KEYCHAIN_SERVICE" -g &>/dev/null 2>&1
    else
        # For non-macOS platforms, assume accessible
        return 0
    fi
}

# Show SSH/keychain troubleshooting help
show_ssh_keychain_help() {
    cat >&2 << 'EOF'
⚠️  Keychain access issue detected in SSH session

The macOS keychain appears to be locked. In SSH sessions, the keychain
cannot display the unlock dialog that appears in GUI sessions.

SOLUTION (choose one):

1. Quick fix - unlock keychain now:
   security unlock-keychain $HOME/Library/Keychains/login.keychain-db

2. Permanent fix - add to ~/.zshrc or ~/.bashrc:
   if [ -n "$SSH_CLIENT" ] || [ -n "$SSH_TTY" ]; then
       security unlock-keychain $HOME/Library/Keychains/login.keychain-db 2>/dev/null || true
   fi

3. Alternative - disable keychain auto-lock:
   Open "Keychain Access" app → Select "login" → Edit → Change Settings for Keychain "login"
   Uncheck "Lock after X minutes of inactivity"

EOF
}

# Fetch API key from credential storage
fetch_api_key() {
    # Check SSH session and keychain access first (macOS)
    if is_ssh_session && [[ "$CREDENTIAL_PLATFORM" == "macos" ]]; then
        if ! check_keychain_accessible; then
            show_ssh_keychain_help
            return 1
        fi
    fi

    local api_key
    api_key="$(credential_fetch "$KEYCHAIN_SERVICE" "$KEYCHAIN_ACCOUNT" 2>/dev/null)" || return 1

    # Basic validation
    if [[ -z "$api_key" ]]; then
        return 1
    fi

    echo "$api_key"
}

# Setup PATH for this session
setup_path() {
    if [[ "${GLM_SKIP_PATH:-}" == "1" ]]; then
        return 0
    fi

    # Add ~/.claude-glm-mcp/bin to PATH if not already there
    local glm_bin="$HOME/.claude-glm-mcp/bin"
    if [[ -d "$glm_bin" ]]; then
        case ":$PATH:" in
            *:"$glm_bin":*) ;;
            *)
                export PATH="$glm_bin:$PATH"
                print_info "Added to PATH: $glm_bin"
                ;;
        esac
    fi
}

# Load MCP configuration from file (safe parsing, not code execution)
load_mcp_config() {
    local config_file="$HOME/.claude-glm-mcp/config/mcp.conf"

    # Default: MCP enabled (more features)
    export GLM_USE_MCP="${GLM_USE_MCP:-1}"

    # Load config file if exists (parse as data, not code)
    if [[ -f "$config_file" ]]; then
        # Extract GLM_USE_MCP value safely (grep + sed, no code execution)
        local mcp_value
        mcp_value=$(grep -E '^GLM_USE_MCP=' "$config_file" 2>/dev/null | tail -1 | sed 's/^GLM_USE_MCP=//' | tr -d '"'"'" | tr -d ' ')

        # Validate: only accept 0 or 1
        if [[ "$mcp_value" == "0" ]] || [[ "$mcp_value" == "1" ]]; then
            export GLM_USE_MCP="$mcp_value"
        elif [[ -n "$mcp_value" ]]; then
            print_warning "Invalid GLM_USE_MCP value in $config_file: '$mcp_value' (expected 0 or 1, using default)"
        fi
    fi
}

# Show GLM MCP Wrapper version
show_glm_version() {
    local version_file="$PROJECT_DIR/VERSION"
    local version="unknown"
    if [[ -f "$version_file" ]]; then
        version="$(cat "$version_file" 2>/dev/null)"
    fi
    echo "claude-by-glm (GLM MCP Wrapper) version $version"
    exit 0
}

# Main execution
main() {
    # Set restrictive umask for security (all files/dirs created will be owner-only)
    umask 077

    # Handle --glm-version flag
    if [[ "${1:-}" == "--glm-version" ]]; then
        show_glm_version
    fi

    # Resolve and validate claude binary BEFORE any secret operations
    # This prevents command execution after credentials are in environment
    local claude_bin
    claude_bin="$(command -v claude)" || handle_error "claude binary not found in PATH"

    # Validate claude is in a trusted location to prevent PATH poisoning
    # Support nvm/volta installations as well
    case "$claude_bin" in
        /usr/bin/claude|/usr/local/bin/claude|/opt/homebrew/bin/claude|"$HOME/.claude-glm-mcp/bin/claude"|"$HOME"/.nvm/*/bin/claude|"$HOME"/.volta/bin/claude)
            # Trusted path - continue
            ;;
        *)
            handle_error "Untrusted claude path: $claude_bin (expected in /usr/bin, /usr/local/bin, /opt/homebrew/bin, ~/.claude-glm-mcp/bin, ~/.nvm/*/bin, or ~/.volta/bin)"
            ;;
    esac

    # Load MCP configuration BEFORE credential operations
    # This function uses command substitution (grep|tail|sed|tr) so must run before secrets
    load_mcp_config

    # Setup PATH BEFORE credential operations
    # This prevents PATH poisoning after secrets enter environment
    setup_path

    # Use separate config directory to fully isolate GLM from official Claude
    # This prevents settings.json sync issues between GLM and official sessions
    export CLAUDE_CONFIG_DIR="$HOME/.claude-glm"

    # Create session-specific settings for isolation (defense in depth)
    # Do this BEFORE fetching credentials so no external commands run after secrets
    local glm_sessions_dir="$CLAUDE_CONFIG_DIR/glm-sessions"
    if ! mkdir -p "$glm_sessions_dir" 2>/dev/null; then
        print_error "Failed to create session directory: $glm_sessions_dir"
        print_info "Check filesystem permissions and available disk space"
        exit 1
    fi

    # Ensure restrictive permissions (700 = owner rwx only)
    chmod 700 "$glm_sessions_dir" || handle_error "Failed to set session directory permissions"

    # Generate unique session ID based on timestamp and PID
    # Use bash builtin if available (4.2+), otherwise use absolute path to date
    local session_id
    local timestamp

    # Check bash version for printf %()T support (requires 4.2+)
    if [[ ${BASH_VERSINFO[0]} -gt 4 ]] || [[ ${BASH_VERSINFO[0]} -eq 4 && ${BASH_VERSINFO[1]} -ge 2 ]]; then
        # Bash 4.2+: Use builtin printf (no external command)
        printf -v timestamp '%(%s)T' -1
    else
        # Bash < 4.2 (e.g., macOS default /bin/bash 3.2): Use absolute path to date
        # Absolute path prevents PATH poisoning
        timestamp=$(/bin/date +%s)
    fi

    session_id="glm-${timestamp}-$$"
    local session_settings="$glm_sessions_dir/$session_id.json"

    # Copy base GLM settings if available, otherwise use default settings
    local base_settings="$CLAUDE_CONFIG_DIR/settings.json"
    if [[ -f "$base_settings" ]]; then
        if ! cp "$base_settings" "$session_settings" 2>/dev/null; then
            print_error "Failed to copy GLM settings from $base_settings"
            print_info "Check filesystem permissions and available disk space"
            exit 1
        fi
    else
        # Create minimal session settings if base doesn't exist
        if ! cat > "$session_settings" << 'EOF'; then
{
  "plugins": []
}
EOF
            print_error "Failed to create session settings: $session_settings"
            exit 1
        fi
    fi

    # Ensure session file is readable only by owner (600 = owner rw only)
    chmod 600 "$session_settings" || handle_error "Failed to set session file permissions"

    # Export CLAUDE_SETTINGS to use session-specific config
    export CLAUDE_SETTINGS="$session_settings"

    # Setup automatic cleanup of session file on exit
    # Use absolute path to prevent PATH poisoning
    trap '/bin/rm -f "$session_settings" 2>/dev/null' EXIT

    # Store session info for cleanup (optional, non-critical)
    echo "$session_id" > "$glm_sessions_dir/.last-session" 2>/dev/null || true

    print_info "Using isolated session settings: $session_settings"

    # NOW fetch credentials - ALL external commands completed before this point
    # Windows special handling
    local api_key
    if [[ "$CREDENTIAL_PLATFORM" == "windows" ]]; then
        if [[ -z "${ZAI_API_KEY:-}" ]]; then
            print_error "ZAI_API_KEY environment variable not set"
            print_info "Set it with: set ZAI_API_KEY=your_api_key"
            exit 1
        fi
        api_key="$ZAI_API_KEY"
    else
        # Fetch API key from credential storage
        # Use if ! pattern to work correctly with set -e
        if ! api_key="$(fetch_api_key)"; then
            cat << EOF
ERROR: Failed to retrieve Z.ai API key from $(get_credential_storage_name).

Required: service="$KEYCHAIN_SERVICE", account="$KEYCHAIN_ACCOUNT"

Please register your API key first:
  ~/.claude-glm-mcp/bin/install-key.sh

Or get one from: https://z.ai/subscribe?ic=EBGYZCJRYJ
EOF
            exit 1
        fi

        # Additional check for empty key
        if [[ -z "$api_key" ]]; then
            print_error "Retrieved API key is empty"
            exit 1
        fi
    fi

    # Export environment variables for Z.ai GLM models
    export ANTHROPIC_AUTH_TOKEN="$api_key"
    export ANTHROPIC_BASE_URL="https://api.z.ai/api/anthropic"
    export ANTHROPIC_DEFAULT_HAIKU_MODEL="glm-4.6"
    export ANTHROPIC_DEFAULT_SONNET_MODEL="glm-4.7"
    export ANTHROPIC_DEFAULT_OPUS_MODEL="glm-5"

    # Optional: Custom model repository
    if [[ -n "${GLM_MODEL_REPO:-}" ]]; then
        export ANTHROPIC_MODEL_REPO="$GLM_MODEL_REPO"
        print_info "Using custom model repository: $GLM_MODEL_REPO"
    fi

    # Activate GLM mode for MCP wrapper (only if MCP is enabled)
    # Note: MCP config already loaded at start of main()
    if [[ "$GLM_USE_MCP" == "1" ]]; then
        export GLM_MODE=1
    else
        print_info "MCP disabled (GLM_USE_MCP=0) - running without MCP tools"
    fi

    # Launch claude with all arguments
    # Force opus model to override UI state caching
    # Security: Use env -i with allowlist to minimize environment exposure
    #   - Only pass essential environment variables
    #   - API key remains exposed to Claude process (inherent to Claude Code design)
    # Note: claude_bin already resolved and validated at start of main()

    # Use minimal trusted PATH to prevent PATH poisoning attacks
    # Include claude_bin directory to support nvm/volta users
    # Don't use exec - let trap cleanup run on exit
    # Use shell builtin to avoid command execution after secret fetch
    # Use absolute path for env to prevent PATH poisoning
    local claude_dir
    claude_dir="${claude_bin%/*}"

    /usr/bin/env -i \
        PATH="/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:/opt/homebrew/bin:$HOME/.claude-glm-mcp/bin:$claude_dir" \
        HOME="$HOME" \
        USER="${USER:-$LOGNAME}" \
        TERM="${TERM:-xterm-256color}" \
        ANTHROPIC_AUTH_TOKEN="$api_key" \
        ANTHROPIC_BASE_URL="$ANTHROPIC_BASE_URL" \
        ANTHROPIC_DEFAULT_HAIKU_MODEL="$ANTHROPIC_DEFAULT_HAIKU_MODEL" \
        ANTHROPIC_DEFAULT_SONNET_MODEL="$ANTHROPIC_DEFAULT_SONNET_MODEL" \
        ANTHROPIC_DEFAULT_OPUS_MODEL="$ANTHROPIC_DEFAULT_OPUS_MODEL" \
        CLAUDE_CONFIG_DIR="$CLAUDE_CONFIG_DIR" \
        CLAUDE_SETTINGS="$CLAUDE_SETTINGS" \
        GLM_MODE="${GLM_MODE:-}" \
        "$claude_bin" --model opus "$@"

    # Capture exit code and exit with it (allows trap to run)
    exit $?
}

main "$@"
