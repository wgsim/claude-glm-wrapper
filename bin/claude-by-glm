#!/bin/bash
#
# claude-by-glm - Claude Code launcher for Z.ai GLM models
#
# This script sets up the environment for using Z.ai GLM models
# with Claude Code, then launches the claude command.
#
# Platform support:
# - macOS: Keychain (security command)
# - Linux: libsecret (secret-tool)
# - Windows: Environment variable (ZAI_API_KEY)
#
# Environment variables:
#   GLM_MODEL_REPO - Optional: Custom model repository URL
#   GLM_SKIP_PATH  - If set, skip PATH modification
#
# Usage:
#   ~/.claude-glm-mcp/bin/claude-by-glm [claude arguments...]
#

set -euo pipefail

# Set trusted PATH immediately to prevent command injection
# This must be done BEFORE any credential handling or external commands
# Note: Not readonly because setup_path() may add project bin directory
export PATH="/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:/opt/homebrew/bin"

# Script directory
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_DIR="$(dirname "$SCRIPT_DIR")"

# Source shared utilities
source "$PROJECT_DIR/scripts/common-utils.sh"

# Source credential abstraction (loads security.conf)
source "$PROJECT_DIR/credentials/common.sh"

# Initialize credential backend
credential_init

# Check if running in SSH session
is_ssh_session() {
    [[ -n "${SSH_CLIENT:-}" ]] || [[ -n "${SSH_TTY:-}" ]] || [[ -n "${SSH_CONNECTION:-}" ]]
}

# Check if keychain is accessible (macOS only)
check_keychain_accessible() {
    if [[ "$CREDENTIAL_PLATFORM" == "macos" ]]; then
        # Try to access keychain without verbose output
        # Use absolute path to prevent PATH poisoning
        /usr/bin/security find-generic-password -s "$KEYCHAIN_SERVICE" -g &>/dev/null 2>&1
    else
        # For non-macOS platforms, assume accessible
        return 0
    fi
}

# Show SSH/keychain troubleshooting help
show_ssh_keychain_help() {
    cat >&2 << 'EOF'
⚠️  Keychain access issue detected in SSH session

The macOS keychain appears to be locked. In SSH sessions, the keychain
cannot display the unlock dialog that appears in GUI sessions.

SOLUTION (choose one):

1. Quick fix - unlock keychain now:
   security unlock-keychain $HOME/Library/Keychains/login.keychain-db

2. Permanent fix - add to ~/.zshrc or ~/.bashrc:
   if [ -n "$SSH_CLIENT" ] || [ -n "$SSH_TTY" ]; then
       security unlock-keychain $HOME/Library/Keychains/login.keychain-db 2>/dev/null || true
   fi

3. Alternative - disable keychain auto-lock:
   Open "Keychain Access" app → Select "login" → Edit → Change Settings for Keychain "login"
   Uncheck "Lock after X minutes of inactivity"

EOF
}

# Fetch API key from credential storage
fetch_api_key() {
    # Check SSH session and keychain access first (macOS)
    if is_ssh_session && [[ "$CREDENTIAL_PLATFORM" == "macos" ]]; then
        if ! check_keychain_accessible; then
            show_ssh_keychain_help
            return 1
        fi
    fi

    local api_key
    api_key="$(credential_fetch "$KEYCHAIN_SERVICE" "$KEYCHAIN_ACCOUNT" 2>/dev/null)" || return 1

    # Basic validation
    if [[ -z "$api_key" ]]; then
        return 1
    fi

    echo "$api_key"
}

# Setup PATH for this session
setup_path() {
    if [[ "${GLM_SKIP_PATH:-}" == "1" ]]; then
        return 0
    fi

    # Add ~/.claude-glm-mcp/bin to PATH if not already there
    local glm_bin="$HOME/.claude-glm-mcp/bin"
    if [[ -d "$glm_bin" ]]; then
        case ":$PATH:" in
            *:"$glm_bin":*) ;;
            *)
                export PATH="$glm_bin:$PATH"
                print_info "Added to PATH: $glm_bin"
                ;;
        esac
    fi
}

# Load MCP configuration from file (safe parsing, not code execution)
load_mcp_config() {
    local config_file="$HOME/.claude-glm-mcp/config/mcp.conf"

    # Default: MCP enabled (more features)
    export GLM_USE_MCP="${GLM_USE_MCP:-1}"

    # Load config file if exists (parse as data, not code)
    if [[ -f "$config_file" ]]; then
        # Extract GLM_USE_MCP value safely (grep + sed, no code execution)
        local mcp_value
        mcp_value=$(grep -E '^GLM_USE_MCP=' "$config_file" 2>/dev/null | tail -1 | sed 's/^GLM_USE_MCP=//' | tr -d '"'"'" | tr -d ' ')

        # Validate: only accept 0 or 1
        if [[ "$mcp_value" == "0" ]] || [[ "$mcp_value" == "1" ]]; then
            export GLM_USE_MCP="$mcp_value"
        elif [[ -n "$mcp_value" ]]; then
            print_warning "Invalid GLM_USE_MCP value in $config_file: '$mcp_value' (expected 0 or 1, using default)"
        fi
    fi
}

# Show GLM MCP Wrapper version
show_glm_version() {
    local version_file="$PROJECT_DIR/VERSION"
    local version="unknown"
    if [[ -f "$version_file" ]]; then
        version="$(cat "$version_file" 2>/dev/null)"
    fi
    echo "claude-by-glm (GLM MCP Wrapper) version $version"
    exit 0
}

# ========================================================================
# SYNC FUNCTIONS (merge session changes back to global config)
# ========================================================================
# Based on official claude-session-wrapper.sh sync logic

# Merge a specific key from source JSON to destination JSON
# Usage: _glm_merge_json_key <src_file> <dst_file> <key>
_glm_merge_json_key() {
    local src="$1"
    local dst="$2"
    local key="$3"

    [[ -f "$src" ]] || return 0

    # Use python3 for JSON merging (same as official script)
    /usr/bin/python3 - "$src" "$dst" "$key" <<'PY' 2>/dev/null
import json
import os
import stat
import sys
import tempfile

src, dst, key = sys.argv[1], sys.argv[2], sys.argv[3]

try:
    with open(src, "r", encoding="utf-8") as f:
        src_data = json.load(f)
except (json.JSONDecodeError, FileNotFoundError):
    sys.exit(0)

src_obj = src_data.get(key)
if not isinstance(src_obj, dict):
    sys.exit(0)

try:
    if os.path.exists(dst):
        with open(dst, "r", encoding="utf-8") as f:
            dst_data = json.load(f)
        if not isinstance(dst_data, dict):
            dst_data = {}
    else:
        dst_data = {}
except (json.JSONDecodeError, FileNotFoundError):
    dst_data = {}

dst_obj = dst_data.get(key)
if not isinstance(dst_obj, dict):
    dst_obj = {}

dst_obj.update(src_obj)
dst_data[key] = dst_obj

dst_dir = os.path.dirname(dst) or "."
fd, tmp_path = tempfile.mkstemp(prefix=".tmp-glm-sync-", dir=dst_dir)
try:
    with os.fdopen(fd, "w", encoding="utf-8") as f:
        json.dump(dst_data, f, indent=2, ensure_ascii=False)
        f.write("\n")
    os.chmod(tmp_path, stat.S_IRUSR | stat.S_IWUSR)
    os.replace(tmp_path, dst)
except Exception:
    if os.path.exists(tmp_path):
        os.unlink(tmp_path)
    raise
PY
    local merge_rc=$?
    if (( merge_rc != 0 )); then
        echo "[claude-by-glm] Warning: Failed to sync key '$key'" >&2
        return 1
    fi
    return 0
}

# Sync session changes back to global config
# Called on session exit before cleanup
_glm_sync_to_global() {
    local session_dir="$1"
    local global_claude_json="$HOME/.claude.json"
    local global_settings="$HOME/.claude/settings.json"

    # Sync mcpServers from session .claude.json to global
    if [[ -f "$session_dir/.claude.json" ]]; then
        _glm_merge_json_key "$session_dir/.claude.json" "$global_claude_json" "mcpServers"
    fi

    # Sync enabledPlugins from session settings.json to global
    if [[ -f "$session_dir/settings.json" ]]; then
        _glm_merge_json_key "$session_dir/settings.json" "$global_settings" "enabledPlugins"
    fi
}

# Main execution
main() {
    # Set restrictive umask for security (all files/dirs created will be owner-only)
    umask 077

    # Handle --glm-version flag
    if [[ "${1:-}" == "--glm-version" ]]; then
        show_glm_version
    fi

    # Resolve and validate claude binary BEFORE any secret operations
    # This prevents command execution after credentials are in environment
    local claude_bin
    claude_bin="$(command -v claude)" || handle_error "claude binary not found in PATH"

    # Validate claude is in a trusted location to prevent PATH poisoning
    # Support nvm/volta installations as well
    case "$claude_bin" in
        /usr/bin/claude|/usr/local/bin/claude|/opt/homebrew/bin/claude|"$HOME/.claude-glm-mcp/bin/claude"|"$HOME"/.nvm/*/bin/claude|"$HOME"/.volta/bin/claude)
            # Trusted path - continue
            ;;
        *)
            handle_error "Untrusted claude path: $claude_bin (expected in /usr/bin, /usr/local/bin, /opt/homebrew/bin, ~/.claude-glm-mcp/bin, ~/.nvm/*/bin, or ~/.volta/bin)"
            ;;
    esac

    # Load MCP configuration BEFORE credential operations
    # This function uses command substitution (grep|tail|sed|tr) so must run before secrets
    load_mcp_config

    # Setup PATH BEFORE credential operations
    # This prevents PATH poisoning after secrets enter environment
    setup_path

    # ========================================================================
    # SESSION-SPECIFIC CLAUDE_CONFIG_DIR ISOLATION
    # ========================================================================
    # Each GLM session gets its own CLAUDE_CONFIG_DIR to prevent:
    # 1. Settings pollution between GLM sessions
    # 2. Conflicts with other session isolation projects (e.g., ~/.claude-per-sessions/)
    # 3. Model selection synchronization between concurrent sessions
    #
    # Directory structure:
    #   ~/.claude-glm/                    # GLM template (shared resources)
    #   ~/.claude-glm-sessions/<id>/      # Per-session isolated config
    # ========================================================================

    # Generate unique session ID: glm-<timestamp>-<pid>
    local session_id
    local timestamp

    # Check bash version for printf %()T support (requires 4.2+)
    if [[ ${BASH_VERSINFO[0]} -gt 4 ]] || [[ ${BASH_VERSINFO[0]} -eq 4 && ${BASH_VERSINFO[1]} -ge 2 ]]; then
        # Bash 4.2+: Use builtin printf (no external command)
        printf -v timestamp '%(%s)T' -1
    else
        # Bash < 4.2 (e.g., macOS default /bin/bash 3.2): Use absolute path to date
        # Absolute path prevents PATH poisoning
        timestamp=$(/bin/date +%s)
    fi

    session_id="glm-${timestamp}-$$"

    # Create session-specific config directory
    local sessions_base="$HOME/.claude-glm-sessions"
    local session_dir="$sessions_base/$session_id"

    # Create with restrictive permissions (umask 077 = owner only)
    if ! ( umask 077 && mkdir -p "$session_dir" ); then
        print_error "Failed to create session directory: $session_dir"
        print_info "Check filesystem permissions and available disk space"
        exit 1
    fi

    # ========================================================================
    # SYMLINK SHARED RESOURCES (read-mostly, shared across all sessions)
    # ========================================================================
    # These are symlinked from official Claude config to maintain consistency
    # and avoid duplication. Updates in one session are reflected in all.
    local shared_items=(plugins commands projects todos CLAUDE.md memory)
    for item in "${shared_items[@]}"; do
        if [[ -e "$HOME/.claude/$item" ]]; then
            ln -sf "$HOME/.claude/$item" "$session_dir/$item" 2>/dev/null || \
                print_info "Warning: Could not symlink $item"
        fi
    done

    # ========================================================================
    # COPY MUTABLE CONFIG (session-specific, can diverge independently)
    # ========================================================================
    # Copy from official Claude config (priority) or GLM template
    # Official config includes enabledPlugins for plugin recognition
    local glm_template="$HOME/.claude-glm"
    local official_config="$HOME/.claude"

    for cfg in settings.json settings.local.json; do
        if [[ -f "$official_config/$cfg" ]]; then
            # Priority: copy from official Claude config (includes enabledPlugins)
            if ! /bin/cp "$official_config/$cfg" "$session_dir/$cfg" 2>/dev/null; then
                print_info "Warning: Could not copy $cfg from ~/.claude"
            else
                chmod 600 "$session_dir/$cfg" 2>/dev/null || true
            fi
        elif [[ -f "$glm_template/$cfg" ]]; then
            # Fallback: copy from GLM template
            if ! /bin/cp "$glm_template/$cfg" "$session_dir/$cfg" 2>/dev/null; then
                print_info "Warning: Could not copy $cfg from template"
            else
                chmod 600 "$session_dir/$cfg" 2>/dev/null || true
            fi
        fi
    done

    # Copy ~/.claude.json (global MCP server configurations) to session
    # This enables MCP servers like model-bridge in isolated sessions
    if [[ -f "$HOME/.claude.json" ]]; then
        if ! /bin/cp "$HOME/.claude.json" "$session_dir/.claude.json" 2>/dev/null; then
            print_info "Warning: Could not copy .claude.json from home directory"
        else
            chmod 600 "$session_dir/.claude.json" 2>/dev/null || true
        fi
    fi

    # Ensure at least a minimal settings.json exists
    if [[ ! -f "$session_dir/settings.json" ]]; then
        cat > "$session_dir/settings.json" << 'EOF'
{
  "plugins": []
}
EOF
        chmod 600 "$session_dir/settings.json" 2>/dev/null || true
    fi

    # ========================================================================
    # SET SESSION-SPECIFIC CLAUDE_CONFIG_DIR
    # ========================================================================
    export CLAUDE_CONFIG_DIR="$session_dir"

    # Store session info for debugging/cleanup utilities
    echo "$session_id" > "$sessions_base/.last-session" 2>/dev/null || true

    print_info "GLM session isolated: $session_dir"

    # Setup sync and cleanup on exit
    # Sync session changes to global config before cleanup
    trap '_glm_sync_to_global "$session_dir"; /bin/rm -rf "$session_dir" 2>/dev/null' EXIT

    # NOW fetch credentials - ALL external commands completed before this point
    # Windows special handling
    local api_key
    if [[ "$CREDENTIAL_PLATFORM" == "windows" ]]; then
        if [[ -z "${ZAI_API_KEY:-}" ]]; then
            print_error "ZAI_API_KEY environment variable not set"
            print_info "Set it with: set ZAI_API_KEY=your_api_key"
            exit 1
        fi
        api_key="$ZAI_API_KEY"
    else
        # Fetch API key from credential storage
        # Use if ! pattern to work correctly with set -e
        if ! api_key="$(fetch_api_key)"; then
            cat << EOF
ERROR: Failed to retrieve Z.ai API key from $(get_credential_storage_name).

Required: service="$KEYCHAIN_SERVICE", account="$KEYCHAIN_ACCOUNT"

Please register your API key first:
  ~/.claude-glm-mcp/bin/install-key.sh

Or get one from: https://z.ai/subscribe?ic=EBGYZCJRYJ
EOF
            exit 1
        fi

        # Additional check for empty key
        if [[ -z "$api_key" ]]; then
            print_error "Retrieved API key is empty"
            exit 1
        fi
    fi

    # Export environment variables for Z.ai GLM models
    export ANTHROPIC_AUTH_TOKEN="$api_key"
    export ANTHROPIC_BASE_URL="https://api.z.ai/api/anthropic"
    export ANTHROPIC_DEFAULT_HAIKU_MODEL="glm-4.6"
    export ANTHROPIC_DEFAULT_SONNET_MODEL="glm-4.7"
    export ANTHROPIC_DEFAULT_OPUS_MODEL="glm-5"

    # Optional: Custom model repository
    if [[ -n "${GLM_MODEL_REPO:-}" ]]; then
        export ANTHROPIC_MODEL_REPO="$GLM_MODEL_REPO"
        print_info "Using custom model repository: $GLM_MODEL_REPO"
    fi

    # Activate GLM mode for MCP wrapper (only if MCP is enabled)
    # Note: MCP config already loaded at start of main()
    if [[ "$GLM_USE_MCP" == "1" ]]; then
        export GLM_MODE=1
    else
        print_info "MCP disabled (GLM_USE_MCP=0) - running without MCP tools"
    fi

    # Launch claude with all arguments
    # Force opus model to override UI state caching
    # Security: Use env -i with allowlist to minimize environment exposure
    #   - Only pass essential environment variables
    #   - API key remains exposed to Claude process (inherent to Claude Code design)
    # Note: claude_bin already resolved and validated at start of main()

    # Use minimal trusted PATH to prevent PATH poisoning attacks
    # Include claude_bin directory to support nvm/volta users
    # Don't use exec - let trap cleanup run on exit
    # Use shell builtin to avoid command execution after secret fetch
    # Use absolute path for env to prevent PATH poisoning
    local claude_dir
    claude_dir="${claude_bin%/*}"

    /usr/bin/env -i \
        PATH="/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:/opt/homebrew/bin:$HOME/.claude-glm-mcp/bin:$claude_dir" \
        HOME="$HOME" \
        USER="${USER:-$LOGNAME}" \
        TERM="${TERM:-xterm-256color}" \
        ANTHROPIC_AUTH_TOKEN="$api_key" \
        ANTHROPIC_BASE_URL="$ANTHROPIC_BASE_URL" \
        ANTHROPIC_DEFAULT_HAIKU_MODEL="$ANTHROPIC_DEFAULT_HAIKU_MODEL" \
        ANTHROPIC_DEFAULT_SONNET_MODEL="$ANTHROPIC_DEFAULT_SONNET_MODEL" \
        ANTHROPIC_DEFAULT_OPUS_MODEL="$ANTHROPIC_DEFAULT_OPUS_MODEL" \
        CLAUDE_CONFIG_DIR="$CLAUDE_CONFIG_DIR" \
        GLM_MODE="${GLM_MODE:-}" \
        "$claude_bin" --model opus "$@"

    # Capture exit code and exit with it (allows trap to run)
    exit $?
}

main "$@"
