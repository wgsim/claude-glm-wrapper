#!/bin/bash
#
# glm-cleanup-sessions - Clean up old GLM session settings
#
# This script removes old session-specific settings files created by
# claude-by-glm. Sessions are stored in ~/.claude/glm-sessions/
#
# Usage:
#   ~/.claude-glm-mcp/bin/glm-cleanup-sessions [options]
#
# Options:
#   --dry-run    Show what would be deleted without actually deleting
#   --keep N     Keep the last N sessions (default: 10)
#   --all        Remove all session files
#   --list       List all sessions with details
#   --session <id> Delete specific session(s)
#
# Automation:
#   Add to crontab for automatic cleanup:
#   0 0 * * * ~/.claude-glm-mcp/bin/glm-cleanup-sessions --keep 10
#

set -euo pipefail

# Detect script directory for sourcing utilities
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"

# Source shared utilities
source "$SCRIPT_DIR/scripts/common-utils.sh"

# Default options
DRY_RUN=0
KEEP_COUNT=10
REMOVE_ALL=0
LIST_MODE=0
DELETE_SESSIONS=()

# Parse arguments
while [[ $# -gt 0 ]]; do
    case "$1" in
        --dry-run)
            DRY_RUN=1
            shift
            ;;
        --keep)
            # Use ${2:-} to safely handle unbound variable under set -u
            keep_arg="${2:-}"
            if [[ -z "$keep_arg" ]] || [[ ! "$keep_arg" =~ ^[0-9]+$ ]] || [[ "$keep_arg" -le 0 ]]; then
                print_error "Invalid --keep value: '${keep_arg:-<missing>}' (must be a positive integer)"
                exit 1
            fi
            KEEP_COUNT="$keep_arg"
            shift 2
            ;;
        --all)
            REMOVE_ALL=1
            shift
            ;;
        --list)
            LIST_MODE=1
            shift
            ;;
        --session)
            shift
            # Collect session IDs to delete
            while [[ $# -gt 0 ]] && [[ ! "$1" =~ ^- ]]; do
                DELETE_SESSIONS+=("$1")
                shift
            done
            ;;
        -h|--help)
            cat << 'EOF'
glm-cleanup-sessions - Clean up old GLM session settings

USAGE:
    glm-cleanup-sessions [options]

OPTIONS:
    --dry-run       Show what would be deleted without actually deleting
    --keep N        Keep the last N sessions (default: 10)
    --all            Remove all session files
    --list           List all sessions with details
    --session <id>   Delete specific session(s) (can specify multiple)

EXAMPLES:
    # Keep last 10 sessions, remove older ones
    glm-cleanup-sessions

    # Keep last 5 sessions
    glm-cleanup-sessions --keep 5

    # List all sessions
    glm-cleanup-sessions --list

    # Delete specific session
    glm-cleanup-sessions --session glm-1738634123-1234

    # Delete multiple sessions
    glm-cleanup-sessions --session glm-1738634123-1234 glm-1738634256-5678

    # Preview what would be deleted
    glm-cleanup-sessions --dry-run
EOF
            exit 0
            ;;
        *)
            print_error "Unknown option: $1"
            echo "Use --help for usage information"
            exit 1
            ;;
    esac
done

# Session directory (use CLAUDE_CONFIG_DIR for v2.0.0+)
# Pin expected base directory to prevent environment manipulation
EXPECTED_BASE="$HOME/.claude-glm"
SESSIONS_DIR="${CLAUDE_CONFIG_DIR:-$EXPECTED_BASE}/glm-sessions"

# Validate sessions directory is within expected location (prevent path manipulation)
if command -v realpath &>/dev/null; then
    canonical_dir="$(realpath "$SESSIONS_DIR" 2>/dev/null)" || {
        print_error "Cannot resolve sessions directory: $SESSIONS_DIR"
        exit 1
    }
    canonical_expected="$(realpath "$EXPECTED_BASE/glm-sessions" 2>/dev/null)" || {
        print_error "Cannot resolve expected directory"
        exit 1
    }

    if [[ "$canonical_dir" != "$canonical_expected" ]]; then
        print_error "Sessions directory outside expected location"
        print_error "  Expected: $canonical_expected"
        print_error "  Got: $canonical_dir"
        exit 1
    fi
else
    # Fallback: fail-closed if realpath not available and path differs from expected
    if [[ "$SESSIONS_DIR" != "$EXPECTED_BASE/glm-sessions" ]]; then
        print_error "Cannot verify sessions directory without realpath command"
        print_error "Install coreutils: brew install coreutils"
        exit 1
    fi
fi

# Check if sessions directory exists
if [[ ! -d "$SESSIONS_DIR" ]]; then
    print_info "No GLM sessions directory found: $SESSIONS_DIR"
    exit 0
fi

# List mode: show all sessions
if [[ $LIST_MODE -eq 1 ]]; then
    print_info "GLM sessions in: $SESSIONS_DIR"
    echo

    # Get all session files sorted by modification time (newest first)
    session_files=()
    while IFS= read -r file; do
        [[ -n "$file" ]] && session_files+=("$file")
    done < <(find "$SESSIONS_DIR" -name "glm-*.json" -type f -print0 2>/dev/null | xargs -0 ls -t 2>/dev/null)

    if [[ ${#session_files[@]} -eq 0 ]]; then
        print_info "No session files found"
        exit 0
    fi

    # Print table header
    printf "%-42s  %-19s  %10s\n" "Session ID" "Modified" "Size"
    printf "%s\n" "-------------------------------------------------------------------------"

    total_size=0
    for file in "${session_files[@]}"; do
        basename_file=$(basename "$file")
        mtime=$(stat -f '%Sm' -t '%Y-%m-%d %H:%M:%S' "$file" 2>/dev/null || stat -c '%y' "$file" 2>/dev/null)
        size=$(stat -f '%z' "$file" 2>/dev/null || stat -c '%s' "$file" 2>/dev/null)

        # Format size
        if [[ $size -lt 1024 ]]; then
            size_str="${size}B"
        elif [[ $size -lt 1048576 ]]; then
            size_str="$((size / 1024))KB"
        else
            size_str="$((size / 1048576))MB"
        fi

        printf "%-42s  %-19s  %10s\n" "$basename_file" "$mtime" "$size_str"
        total_size=$((total_size + size))
    done

    echo
    echo "Total sessions: ${#session_files[@]}"
    echo "Total size: $total_size bytes"
    exit 0
fi

# Validate session ID to prevent path traversal
validate_session_id() {
    local session_id="$1"

    # Remove .json extension if present
    session_id="${session_id%.json}"

    # Must match glm-TIMESTAMP-PID format
    if [[ ! "$session_id" =~ ^glm-[0-9]+-[0-9]+$ ]]; then
        print_error "Invalid session ID format: $session_id"
        print_info "Expected format: glm-TIMESTAMP-PID"
        return 1
    fi

    # Reject any path traversal attempts
    if [[ "$session_id" =~ [./\\] ]]; then
        print_error "Session ID contains invalid characters: $session_id"
        return 1
    fi

    return 0
}

# Delete specific sessions mode
if [[ ${#DELETE_SESSIONS[@]} -gt 0 ]]; then
    print_info "Deleting ${#DELETE_SESSIONS[@]} specific session(s)..."

    deleted=0
    not_found=0
    for session_id in "${DELETE_SESSIONS[@]}"; do
        # Validate session ID format (security check)
        if ! validate_session_id "$session_id"; then
            print_error "Skipping invalid session ID: $session_id"
            not_found=$((not_found + 1))
            continue
        fi

        # Remove .json extension for consistent handling
        session_id="${session_id%.json}"

        # Construct and validate path
        session_file="$SESSIONS_DIR/$session_id.json"

        # Canonicalize path and verify it's within SESSIONS_DIR
        if command -v realpath &>/dev/null; then
            canonical_path="$(realpath "$session_file" 2>/dev/null || echo "$session_file")"
            canonical_dir="$(realpath "$SESSIONS_DIR" 2>/dev/null || echo "$SESSIONS_DIR")"

            if [[ "$canonical_path" != "$canonical_dir"/* ]]; then
                print_error "Session path outside sessions directory: $session_id"
                not_found=$((not_found + 1))
                continue
            fi
        fi

        if [[ -f "$session_file" ]]; then
            if [[ $DRY_RUN -eq 1 ]]; then
                echo "  Would delete: $session_file"
            else
                rm -f "$session_file"
                deleted=$((deleted + 1))
            fi
        else
            print_warning "Session not found: $session_id"
            not_found=$((not_found + 1))
        fi
    done

    if [[ $DRY_RUN -eq 1 ]]; then
        print_info "[DRY RUN] Would delete $deleted session(s), $not_found not found"
    else
        print_success "Deleted $deleted session(s), $not_found not found"
    fi

    if [[ $deleted -eq 0 ]]; then
        exit 0
    fi

    # Show remaining sessions
    remaining=$(find "$SESSIONS_DIR" -name "glm-*.json" -type f 2>/dev/null | wc -l | tr -d ' ')
    echo
    print_info "Remaining session files: $remaining"
    exit 0
fi

# Count total session files
total_sessions=$(find "$SESSIONS_DIR" -name "glm-*.json" -type f 2>/dev/null | wc -l | tr -d ' ')

if [[ $total_sessions -eq 0 ]]; then
    print_info "No session files found in: $SESSIONS_DIR"
    exit 0
fi

print_info "Found $total_sessions session file(s) in: $SESSIONS_DIR"

# Remove all mode
if [[ $REMOVE_ALL -eq 1 ]]; then
    if [[ $DRY_RUN -eq 1 ]]; then
        print_info "[DRY RUN] Would remove all $total_sessions session file(s)"
        find "$SESSIONS_DIR" -name "glm-*.json" -type f -print
    else
        print_info "Removing all session files..."
        find "$SESSIONS_DIR" -name "glm-*.json" -type f -delete
        print_success "Removed all $total_sessions session file(s)"
    fi
    exit 0
fi

# Normal mode: keep last N sessions
# Find all session files sorted by modification time (newest first)
session_files=()
while IFS= read -r file; do
    [[ -n "$file" ]] && session_files+=("$file")
done < <(find "$SESSIONS_DIR" -name "glm-*.json" -type f -print0 2>/dev/null | xargs -0 ls -t 2>/dev/null)

# Calculate how many to delete
if [[ ${#session_files[@]} -le $KEEP_COUNT ]]; then
    print_info "Only ${#session_files[@]} session file(s) exist (keeping $KEEP_COUNT)"
    print_info "Nothing to clean up"
    exit 0
fi

# Files to keep (first KEEP_COUNT)
keep_files=("${session_files[@]:0:$KEEP_COUNT}")

# Files to delete (remaining)
delete_files=("${session_files[@]:$KEEP_COUNT}")

if [[ ${#delete_files[@]} -eq 0 ]]; then
    print_info "No files to delete (keeping $KEEP_COUNT most recent)"
    exit 0
fi

# Show what would be deleted
print_info "Keeping last $KEEP_COUNT session(s):"
for file in "${keep_files[@]}"; do
    mtime=$(stat -f '%Sm' -t '%Y-%m-%d %H:%M:%S' "$file" 2>/dev/null || stat -c '%y' "$file" 2>/dev/null)
    basename_file=$(basename "$file")
    echo "  - $basename_file (modified: $mtime)"
done

print_info "Would delete ${#delete_files[@]} old session(s):"
for file in "${delete_files[@]}"; do
    mtime=$(stat -f '%Sm' -t '%Y-%m-%d %H:%M:%S' "$file" 2>/dev/null || stat -c '%y' "$file" 2>/dev/null)
    basename_file=$(basename "$file")
    echo "  - $basename_file (modified: $mtime)"
done

# Dry run mode
if [[ $DRY_RUN -eq 1 ]]; then
    print_warning "[DRY RUN] Would delete ${#delete_files[@]} file(s)"
    print_info "Run again without --dry-run to actually delete"
    exit 0
fi

# Confirm deletion
echo
read -rp "Delete ${#delete_files[@]} old session(s)? (y/N): " -n 1 response
echo
if [[ ! $response =~ ^[Yy]$ ]]; then
    print_info "Cancelled"
    exit 0
fi

# Delete old session files
print_info "Deleting old session files..."
deleted=0
for file in "${delete_files[@]}"; do
    rm -f "$file"
    deleted=$((deleted + 1))
done

print_success "Deleted $deleted old session file(s)"

# Show remaining sessions
remaining=$(find "$SESSIONS_DIR" -name "glm-*.json" -type f 2>/dev/null | wc -l | tr -d ' ')
echo
print_info "Remaining session files: $remaining"
